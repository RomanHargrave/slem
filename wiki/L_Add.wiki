#sidebar TableOfContents

{{{



case class L_Add(LHSin : L_Value, RHSin : L_Value) extends L_BinOpInstruction(LHSin, RHSin)
{
    override val instructionString = "add"
}
    
case class L_NSWAdd(LHSin : L_Value, RHSin : L_Value) extends L_BinOpInstruction(LHSin, RHSin)
{
    override val instructionString = "add nsw"
}
    
case class L_NUWAdd(LHSin : L_Value, RHSin : L_Value) extends L_BinOpInstruction(LHSin, RHSin)
{
    override val instructionString = "add nuw"
}
    
case class L_NUWNSWAdd(LHSin : L_Value, RHSin : L_Value) extends L_BinOpInstruction(LHSin, RHSin)
{
    override val instructionString = "add nuw nsw"
}

}}}

Constructs an 'add' instruction. Takes a pair of values for LHS/RHS respectively as parameters. 

The various classes represent the configurations for no signed wrap/no unsigned wrap for this add instruction - see the LLVM Assembly Reference - [http://llvm.org/docs/LangRef.html#i_add 'add' Instruction]

Emitted LLVM IR:
{{{
For an add instruction 'n':

  <n->ssa> = add <LHSin->resultType> <encodeValue(LHSin)>, <encodeValue(RHSin)>        
  <n->ssa> = add nuw <LHSin->resultType> <encodeValue(LHSin)>, <encodeValue(RHSin)>    
  <n->ssa> = add nsw <LHSin->resultType> <encodeValue(LHSin)>, <encodeValue(RHSin)>    
  <n->ssa> = add nuw nsw <LHSin->resultType> <encodeValue(LHSin)>, <encodeValue(RHSin)>
}}}